
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Post-Quantum Cryptography Benchmark (Optimized)</title>
    <style>
        :root {
            --primary: #6200EA;
            --primary-light: #9d46ff;
            --secondary: #03DAC6;
            --dark: #121212;
            --light: #f5f5f5;
            --error: #ff4444;
            --warning: #ffbb33;
            --success: #00C851;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--dark);
            color: var(--light);
            line-height: 1.6;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-top: 0.5rem;
        }
        
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--primary);
        }
        
        .optimization-card {
            border-left: 4px solid var(--secondary);
        }
        
        .status-container {
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-indicator.supported {
            background-color: var(--success);
        }
        
        .status-indicator.unsupported {
            background-color: var(--error);
        }
        
        .status-message {
            font-weight: 500;
        }
        
        .supported {
            color: var(--success);
        }
        
        .unsupported {
            color: var(--error);
        }
        
        .warning {
            color: var(--warning);
        }
        
        .benchmark-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            background-color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button.running {
            background-color: var(--warning);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 1;
            }
        }
        
        select, input {
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            font-size: 1rem;
        }
        
        .benchmark-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .benchmark-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .benchmark-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }
        
        .benchmark-title {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            color: var(--secondary);
        }
        
        .benchmark-description {
            color: #ccc;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .result-container {
            margin-top: 1.5rem;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .result-label {
            font-weight: 500;
        }
        
        .result-value {
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        .speedup-text {
            font-weight: bold;
            font-size: 1.1rem;
            margin-top: 1rem;
            padding: 0.5rem;
            text-align: center;
            background-color: rgba(0, 200, 81, 0.1);
            border-radius: 4px;
        }
        
        .chart-container {
            margin-top: 1rem;
            height: 180px;
            position: relative;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(18, 18, 18, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(3px);
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--secondary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .log-container {
            margin-top: 2rem;
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
        }
        
        .log-entry.info {
            color: #63B1FF;
        }
        
        .log-entry.error {
            color: var(--error);
        }
        
        .log-entry.success {
            color: var(--success);
        }
        
        .log-time {
            color: #888;
            margin-right: 0.5rem;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 2rem;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
            color: #999;
        }
        
        .chart-bar {
            position: relative;
            height: 30px;
            margin: 8px 0;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .chart-label {
            position: absolute;
            left: 10px;
            top: 5px;
            z-index: 1;
            font-size: 0.8rem;
        }
        
        .chart-fill {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
            transition: width 1s ease-out;
        }
        
        .chart-fill.cpu {
            background-color: var(--primary);
            width: 0%;
        }
        
        .chart-fill.gpu {
            background-color: var(--secondary);
            width: 0%;
        }
        
        .optimized .chart-fill.gpu {
            background-color: var(--success);
        }
        
        .optimization-toggle {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.05);
            transition: all 0.2s ease;
        }
        
        .optimization-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-right: 5px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #666;
            transition: .4s;
            border-radius: 20px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--success);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        .optimization-notes {
            margin-top: 1rem;
            padding: 1rem;
            background-color: rgba(3, 218, 198, 0.05);
            border-radius: 4px;
            border-left: 4px solid var(--secondary);
        }
        
        @media (max-width: 768px) {
            main {
                padding: 1rem;
            }
            
            header {
                padding: 1.5rem 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .benchmark-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>WebGPU Post-Quantum Cryptography Benchmark</h1>
        <div class="subtitle">Optimized for difficult computations</div>
    </header>
    
    <main>
        <div class="card">
            <h2>System Capabilities</h2>
            <div class="status-container">
                <div>
                    <span class="status-indicator" id="webgpu-status"></span>
                    <span class="status-message" id="webgpu-message">Checking WebGPU support...</span>
                </div>
                <div id="adapter-info"></div>
            </div>
            <div id="device-limits" class="status-container"></div>
        </div>
        
        <div class="card optimization-card">
            <h2>Optimization Settings</h2>
            <p>Based on benchmark data, we've implemented specific optimizations for operations where WebGPU was slower than CPU.</p>
            
            <div class="benchmark-controls">
                <label class="optimization-toggle">
                    <span>Use Optimized Implementations</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="optimization-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </label>
                
                <label class="optimization-toggle">
                    <span>Batch Multiple Operations</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="batch-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </label>
                
                <select id="batch-size">
                    <option value="4">Batch Size: 4</option>
                    <option value="8">Batch Size: 8</option>
                    <option value="16" selected>Batch Size: 16</option>
                    <option value="32">Batch Size: 32</option>
                    <option value="64">Batch Size: 64</option>
                </select>
            </div>
            
            <div class="optimization-notes">
                <h3>Optimization Strategies:</h3>
                <ul>
                    <li><strong>NTT:</strong> Stockham algorithm with shared memory, multi-batch processing</li>
                    <li><strong>Homomorphic Operations:</strong> Batched computations, minimized data transfers</li>
                    <li><strong>Polynomial Multiplication:</strong> FFT-based approach with coalesced memory access</li>
                    <li><strong>General:</strong> Persistent buffers, workgroup tuning, compute-shader-friendly algorithms</li>
                </ul>
            </div>
        </div>
        
        <div class="card">
            <h2>Benchmark Controls</h2>
            <div class="benchmark-controls">
                <select id="workload-size">
                    <option value="small">Small (Fast)</option>
                    <option value="medium" selected>Medium (Balanced)</option>
                    <option value="large">Large (Intensive)</option>
                    <option value="extreme">Extreme (May crash browser)</option>
                </select>
                
                <select id="iteration-count">
                    <option value="1">1 Iteration</option>
                    <option value="3" selected>3 Iterations</option>
                    <option value="5">5 Iterations</option>
                    <option value="10">10 Iterations</option>
                </select>
                
                <button id="run-all-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="13 17 18 12 13 7"></polyline>
                        <polyline points="6 17 11 12 6 7"></polyline>
                    </svg>
                    Run All Benchmarks
                </button>
                
                <button id="clear-results-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Clear Results
                </button>
            </div>
            
            <div class="benchmark-grid">
                <div class="benchmark-card">
                    <h3 class="benchmark-title">Matrix Multiplication</h3>
                    <div class="benchmark-description">Core operation for lattice-based cryptography and neural network processing.</div>
                    
                    <button class="benchmark-btn" data-benchmark="matrix">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="matrix"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="matrix"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="matrix-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="matrix-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="matrix-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card optimized">
                    <h3 class="benchmark-title">NTT (Number Theoretic Transform)</h3>
                    <div class="benchmark-description">Essential for lattice-based schemes like Kyber and Dilithium. <strong>Optimized!</strong></div>
                    
                    <button class="benchmark-btn" data-benchmark="ntt">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="ntt"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="ntt"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="ntt-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="ntt-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="ntt-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card optimized">
                    <h3 class="benchmark-title">Homomorphic Vector Operations</h3>
                    <div class="benchmark-description">Fundamental operations for homomorphic encryption schemes. <strong>Optimized!</strong></div>
                    
                    <button class="benchmark-btn" data-benchmark="homomorphic">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="homomorphic"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="homomorphic"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="homomorphic-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="homomorphic-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="homomorphic-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card optimized">
                    <h3 class="benchmark-title">Polynomial Multiplication</h3>
                    <div class="benchmark-description">Key operation in Ring-LWE based cryptography. <strong>Optimized!</strong></div>
                    
                    <button class="benchmark-btn" data-benchmark="polynomial">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="polynomial"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="polynomial"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="polynomial-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="polynomial-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="polynomial-speedup">Run benchmark to see results</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Execution Log</h2>
            <div class="log-container" id="log-container"></div>
        </div>
    </main>
    
    <footer>
        <p>WebGPU Post-Quantum Cryptography Benchmark Tool • 2025</p>
        <p>For demonstration purposes only. Results may vary based on hardware, drivers, and browser implementation.</p>
    </footer>
    
    <script>
// Utility Functions
function logMessage(message, type = 'info') {
    const logContainer = document.getElementById('log-container');
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry ${type}`;
    
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    
    logEntry.innerHTML = `<span class="log-time">[${timeStr}]</span> ${message}`;
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

function formatTime(ms) {
    if (ms < 1) {
        return `${(ms * 1000).toFixed(2)} µs`;
    } else if (ms < 1000) {
        return `${ms.toFixed(2)} ms`;
    } else {
        return `${(ms / 1000).toFixed(2)} s`;
    }
}

function getWorkloadSizes() {
    const sizeOption = document.getElementById('workload-size').value;
    
    switch (sizeOption) {
        case 'small':
            return {
                matrixSize: 512,
                nttSize: 1024,
                homomorphicSize: 4096,
                polynomialDegree: 512
            };
        case 'medium':
            return {
                matrixSize: 1024,
                nttSize: 2048,
                homomorphicSize: 8192,
                polynomialDegree: 1024
            };
        case 'large':
            return {
                matrixSize: 2048,
                nttSize: 4096,
                homomorphicSize: 16384,
                polynomialDegree: 2048
            };
        case 'extreme':
            return {
                matrixSize: 4096,
                nttSize: 8192,
                homomorphicSize: 32768,
                polynomialDegree: 4096
            };
        default:
            return {
                matrixSize: 1024,
                nttSize: 2048,
                homomorphicSize: 8192,
                polynomialDegree: 1024
            };
    }
}

function getIterationCount() {
    return parseInt(document.getElementById('iteration-count').value);
}

function getBatchSize() {
    return parseInt(document.getElementById('batch-size').value);
}

function isOptimizationEnabled() {
    return document.getElementById('optimization-toggle').checked;
}

function isBatchingEnabled() {
    return document.getElementById('batch-toggle').checked;
}

function updateBenchmarkUI(benchmark, state) {
    const buttons = document.querySelectorAll(`.benchmark-btn[data-benchmark="${benchmark}"]`);
    buttons.forEach(button => {
        if (state === 'running') {
            button.disabled = true;
            button.classList.add('running');
            button.innerHTML = '<div class="loading-spinner"></div> Running...';
        } else if (state === 'complete') {
            button.disabled = false;
            button.classList.remove('running');
            button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Run Again';
        } else {
            button.disabled = false;
            button.classList.remove('running');
            button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Run Benchmark';
        }
    });
}

function updateBenchmarkResults(benchmark, cpuTime, gpuTime) {
    document.getElementById(`${benchmark}-cpu`).textContent = formatTime(cpuTime);
    document.getElementById(`${benchmark}-gpu`).textContent = formatTime(gpuTime);
    
    const speedup = cpuTime / gpuTime;
    const speedupElement = document.getElementById(`${benchmark}-speedup`);
    
    if (speedup >= 1) {
        speedupElement.textContent = `WebGPU is ${speedup.toFixed(1)}x faster`;
        speedupElement.style.backgroundColor = 'rgba(0, 200, 81, 0.1)';
    } else {
        speedupElement.textContent = `CPU is ${(1/speedup).toFixed(1)}x faster`;
        speedupElement.style.backgroundColor = 'rgba(255, 68, 68, 0.1)';
    }
    
    // Update chart bars
    const maxTime = Math.max(cpuTime, gpuTime);
    const cpuBar = document.querySelector(`.chart-fill.cpu[data-benchmark="${benchmark}"]`);
    const gpuBar = document.querySelector(`.chart-fill.gpu[data-benchmark="${benchmark}"]`);
    
    cpuBar.style.width = `${(cpuTime / maxTime) * 100}%`;
    gpuBar.style.width = `${(gpuTime / maxTime) * 100}%`;
    
    cpuBar.textContent = formatTime(cpuTime);
    gpuBar.textContent = formatTime(gpuTime);
}

function clearResults() {
    const benchmarks = ['matrix', 'ntt', 'homomorphic', 'polynomial'];
    benchmarks.forEach(benchmark => {
        document.getElementById(`${benchmark}-cpu`).textContent = '-';
        document.getElementById(`${benchmark}-gpu`).textContent = '-';
        document.getElementById(`${benchmark}-speedup`).textContent = 'Run benchmark to see results';
        document.getElementById(`${benchmark}-speedup`).style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
        
        const cpuBar = document.querySelector(`.chart-fill.cpu[data-benchmark="${benchmark}"]`);
        const gpuBar = document.querySelector(`.chart-fill.gpu[data-benchmark="${benchmark}"]`);
        
        cpuBar.style.width = '0%';
        gpuBar.style.width = '0%';
        cpuBar.textContent = '';
        gpuBar.textContent = '';
    });
    
    logMessage('Results cleared', 'info');
}

// CPU Implementations
function cpuMatrixMultiply(size) {
    const a = new Array(size);
    const b = new Array(size);
    const result = new Array(size);
    
    // Initialize matrices
    for (let i = 0; i < size; i++) {
        a[i] = new Array(size);
        b[i] = new Array(size);
        result[i] = new Array(size);
        
        for (let j = 0; j < size; j++) {
            a[i][j] = Math.random();
            b[i][j] = Math.random();
            result[i][j] = 0;
        }
    }
    
    const startTime = performance.now();
    
    // Perform matrix multiplication
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            for (let k = 0; k < size; k++) {
                result[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    
    const endTime = performance.now();
    return endTime - startTime;
}

function cpuNTT(size) {
    // Prime modulus for NTT (a Mersenne prime: 2^31 - 1)
    const MOD = 2147483647;
    
    // Generate random array
    const arr = new Array(size);
    for (let i = 0; i < size; i++) {
        arr[i] = Math.floor(Math.random() * MOD);
    }
    
    const startTime = performance.now();
    
    // Bit-reversed copy
    function bitReverseCopy(a) {
        const n = a.length;
        const result = new Array(n);
        
        // Calculate number of bits needed
        let bits = 0;
        while ((1 << bits) < n) bits++;
        
        // Perform bit reversal
        for (let i = 0; i < n; i++) {
            let reversed = 0;
            for (let j = 0; j < bits; j++) {
                if (i & (1 << j)) {
                    reversed |= (1 << (bits - 1 - j));
                }
            }
            result[reversed] = a[i];
        }
        
        return result;
    }
    
    // Calculate w^k mod MOD where w is the nth primitive root of unity
    function modPow(base, exponent, modulus) {
        if (modulus === 1) return 0;
        
        let result = 1;
        base = base % modulus;
        
        while (exponent > 0) {
            if (exponent % 2 === 1) {
                result = (result * base) % modulus;
            }
            exponent = Math.floor(exponent / 2);
            base = (base * base) % modulus;
        }
        
        return result;
    }
    
    // Find primitive root of unity
    function findPrimitiveRoot(n, mod) {
        // For simplicity, we're using 3 which is a primitive root for MOD=2^31-1
        // In a real implementation, we would find an appropriate root
        return 3;
    }
    
    // Simple NTT implementation (Cooley-Tukey algorithm)
    function ntt(a, mod) {
        const n = a.length;
        
        // Check if n is a power of 2
        if ((n & (n - 1)) !== 0) {
            throw new Error("Size must be a power of 2");
        }
        
        // Bit-reverse copy
        let result = bitReverseCopy(a);
        
        // Find primitive nth root of unity
        const primitive = findPrimitiveRoot(n, mod);
        
        // NTT computation
        for (let len = 2; len <= n; len *= 2) {
            const halfLen = len / 2;
            const wn = modPow(primitive, (mod - 1) / len, mod);
            
            for (let i = 0; i < n; i += len) {
                let w = 1;
                for (let j = 0; j < halfLen; j++) {
                    const u = result[i + j];
                    const v = (result[i + j + halfLen] * w) % mod;
                    
                    result[i + j] = (u + v) % mod;
                    result[i + j + halfLen] = (u - v + mod) % mod;
                    
                    w = (w * wn) % mod;
                }
            }
        }
        
        return result;
    }
    
    // Perform the NTT
    const result = ntt(arr, MOD);
    
    const endTime = performance.now();
    return endTime - startTime;
}

function cpuHomomorphicVectorAdd(size, batchCount = 1) {
    // Simulate homomorphic encryption parameters
    const modulus = 1n << 30n; // A large modulus
    
    // Generate random encrypted vectors (simulated)
    const vectors = [];
    
    for (let batch = 0; batch < batchCount; batch++) {
        const vecA = new Array(size);
        const vecB = new Array(size);
        const result = new Array(size);
        
        for (let i = 0; i < size; i++) {
            // In real homomorphic encryption, these would be ciphertexts
            // We're simulating with random BigInts
            vecA[i] = BigInt(Math.floor(Math.random() * Number(modulus)));
            vecB[i] = BigInt(Math.floor(Math.random() * Number(modulus)));
        }
        
        vectors.push({ vecA, vecB, result });
    }
    
    const startTime = performance.now();
    
    // Perform homomorphic operations for each batch
    for (let batch = 0; batch < batchCount; batch++) {
        const { vecA, vecB, result } = vectors[batch];
        
        // Perform homomorphic addition (element-wise modular addition)
        for (let i = 0; i < size; i++) {
            result[i] = (vecA[i] + vecB[i]) % modulus;
        }
        
        // Additional operations commonly done in HE (scale, multiply, etc.)
        if (batch % 2 === 0) {
            // Simulated homomorphic multiplication by a scalar
            const scalar = BigInt(Math.floor(Math.random() * 100));
            for (let i = 0; i < size; i++) {
                result[i] = (result[i] * scalar) % modulus;
            }
        } else {
            // Simulated homomorphic rotation (shift)
            const temp = result[0];
            for (let i = 0; i < size - 1; i++) {
                result[i] = result[i + 1];
            }
            result[size - 1] = temp;
        }
    }
    
    const endTime = performance.now();
    return endTime - startTime;
}

function cpuPolynomialMultiply(degree) {
    // Create random polynomials with coefficients in range [0, 2^16)
    const polyA = new Array(degree);
    const polyB = new Array(degree);
    const result = new Array(2 * degree - 1).fill(0);
    
    for (let i = 0; i < degree; i++) {
        polyA[i] = Math.floor(Math.random() * 65536);
        polyB[i] = Math.floor(Math.random() * 65536);
    }
    
    const startTime = performance.now();
    
    // Perform polynomial multiplication (convolution)
    for (let i = 0; i < degree; i++) {
        for (let j = 0; j < degree; j++) {
            result[i + j] += polyA[i] * polyB[j];
        }
    }
    
    const endTime = performance.now();
    return endTime - startTime;
}

// WebGPU Implementation
async function initWebGPU() {
    if (!navigator.gpu) {
        throw new Error("WebGPU not supported on this browser.");
    }
    
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
        throw new Error("Couldn't request WebGPU adapter.");
    }
    
    const device = await adapter.requestDevice();
    return { adapter, device };
}

async function gpuMatrixMultiply(device, size) {
    // Matrix multiplication shader using shared memory and workgroup optimization
    const shaderCode = `
        @group(0) @binding(0) var<storage, read> a: array<f32>;
        @group(0) @binding(1) var<storage, read> b: array<f32>;
        @group(0) @binding(2) var<storage, read_write> result: array<f32>;
        
        struct Uniforms {
            size: u32,
        };
        
        @group(0) @binding(3) var<uniform> uniforms: Uniforms;
        
        var<workgroup> tile_a: array<array<f32, 16>, 16>;
        var<workgroup> tile_b: array<array<f32, 16>, 16>;
        
        @compute @workgroup_size(16, 16)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>) {
            let row = global_id.x;
            let col = global_id.y;
            let size = uniforms.size;
            
            if (row >= size || col >= size) {
                return;
            }
            
            let tileSize = 16u;
            let numTiles = (size + tileSize - 1u) / tileSize;
            
            var sum: f32 = 0.0;
            
            // Loop over tiles
            for (var t: u32 = 0u; t < numTiles; t++) {
                // Load tile into shared memory
                let tileRow = local_id.x;
                let tileCol = local_id.y;
                
                let aRow = workgroup_id.x * tileSize + tileRow;
                let aCol = t * tileSize + tileCol;
                
                let bRow = t * tileSize + tileRow;
                let bCol = workgroup_id.y * tileSize + tileCol;
                
                // Load tile A
                if (aRow < size && aCol < size) {
                    tile_a[tileRow][tileCol] = a[aRow * size + aCol];
                } else {
                    tile_a[tileRow][tileCol] = 0.0;
                }
                
                // Load tile B
                if (bRow < size && bCol < size) {
                    tile_b[tileRow][tileCol] = b[bRow * size + bCol];
                } else {
                    tile_b[tileRow][tileCol] = 0.0;
                }
                
                // Synchronize workgroup to ensure all threads have loaded data
                workgroupBarrier();
                
                // Compute partial dot product using tile
                for (var k: u32 = 0u; k < tileSize; k++) {
                    sum += tile_a[tileRow][k] * tile_b[k][tileCol];
                }
                
                // Synchronize before loading new tiles
                workgroupBarrier();
            }
            
            // Write result
            if (row < size && col < size) {
                result[row * size + col] = sum;
            }
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Initialize matrices with random data
    const a = new Float32Array(size * size);
    const b = new Float32Array(size * size);
    const result = new Float32Array(size * size);
    
    for (let i = 0; i < size * size; i++) {
        a[i] = Math.random();
        b[i] = Math.random();
    }
    
    // Create GPU buffers
    const aBuffer = device.createBuffer({
        size: a.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const bBuffer = device.createBuffer({
        size: b.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const resultBuffer = device.createBuffer({
        size: result.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 4, // Single u32 for size
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(aBuffer, 0, a);
    device.queue.writeBuffer(bBuffer, 0, b);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: aBuffer }
            },
            {
                binding: 1,
                resource: { buffer: bBuffer }
            },
            {
                binding: 2,
                resource: { buffer: resultBuffer }
            },
            {
                binding: 3,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Dispatch workgroups
    const workgroupSize = 16;
    const workgroupCount = Math.ceil(size / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCount, workgroupCount);
    computePass.end();
    
    // Submit GPU commands
    const startTime = performance.now();
    const gpuCommands = commandEncoder.finish();
    device.queue.submit([gpuCommands]);
    
    // Wait for GPU to finish
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    return endTime - startTime;
}

async function gpuNTT(device, size) {
    // Use optimized implementation if enabled
    if (isOptimizationEnabled()) {
        return gpuNTTOptimized(device, size);
    }
    
    // NTT shader using Cooley-Tukey algorithm
    const shaderCode = `
        @group(0) @binding(0) var<storage, read> input: array<u32>;
        @group(0) @binding(1) var<storage, read_write> output: array<u32>;
        
        struct Uniforms {
            size: u32,
            stage: u32,
            halfStageSize: u32,
            omega: u32,
            modulus: u32
        };
        
        @group(0) @binding(2) var<uniform> uniforms: Uniforms;
        
        // Modular multiplication avoiding overflow
        fn mulMod(a: u32, b: u32, mod: u32) -> u32 {
            return u32(((u64(a) * u64(b)) % u64(mod)));
        }
        
        // Modular addition
        fn addMod(a: u32, b: u32, mod: u32) -> u32 {
            let sum = a + b;
            return select(sum, sum - mod, sum >= mod);
        }
        
        // Modular subtraction
        fn subMod(a: u32, b: u32, mod: u32) -> u32 {
            return select(a - b, a - b + mod, a < b);
        }
        
        @compute @workgroup_size(256)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
            let idx = global_id.x;
            let stage = uniforms.stage;
            let halfStageSize = uniforms.halfStageSize;
            let modulus = uniforms.modulus;
            
            // Check if this thread should process data
            if (idx >= uniforms.size / 2) {
                return;
            }
            
            // Calculate indices for butterfly operation
            let stageSize = halfStageSize * 2;
            let stageIndex = idx / halfStageSize;
            let butterflyIndex = idx % halfStageSize;
            
            let i1 = stageIndex * stageSize + butterflyIndex;
            let i2 = i1 + halfStageSize;
            
            // Skip if indices are out of bounds
            if (i2 >= uniforms.size) {
                return;
            }
            
            // Read values
            let x1 = input[i1];
            let x2 = input[i2];
            
            // Calculate twiddle factor
            let w = 1u;
            if (butterflyIndex > 0) {
                w = mulMod(uniforms.omega, butterflyIndex, modulus);
            }
            
            // Butterfly operation
            let y1 = addMod(x1, mulMod(x2, w, modulus), modulus);
            let y2 = subMod(x1, mulMod(x2, w, modulus), modulus);
            
            // Write results
            output[i1] = y1;
            output[i2] = y2;
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Initialize input data with random values
    const MOD = 2147483647; // 2^31 - 1 (Mersenne prime)
    const input = new Uint32Array(size);
    for (let i = 0; i < size; i++) {
        input[i] = Math.floor(Math.random() * MOD);
    }
    
    // Create GPU buffers
    const inputBuffer = device.createBuffer({
        size: input.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });
    
    const outputBuffer = device.createBuffer({
        size: input.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 5 * 4, // 5 u32 values
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write input data to GPU
    device.queue.writeBuffer(inputBuffer, 0, input);
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Calculate the number of stages (log2 of size)
    const numStages = Math.log2(size);
    
    // Prepare for timing
    const startTime = performance.now();
    
    // Create bind groups and execute stages
    let sourceBuffer = inputBuffer;
    let destBuffer = outputBuffer;
    
    for (let stage = 0; stage < numStages; stage++) {
        const stageSize = 2 ** (stage + 1);
        const halfStageSize = stageSize / 2;
        
        // A primitive root for our modulus
        const omega = 3; // For simplicity using a value that works for our modulus
        
        // Update uniform buffer for this stage
        device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([
            size,           // size
            stage,          // stage
            halfStageSize,  // halfStageSize
            omega,          // omega (primitive root)
            MOD             // modulus
        ]));
        
        // Create bind group for this stage
        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: { buffer: sourceBuffer }
                },
                {
                    binding: 1,
                    resource: { buffer: destBuffer }
                },
                {
                    binding: 2,
                    resource: { buffer: uniformBuffer }
                }
            ]
        });
        
        // Execute this stage
        const commandEncoder = device.createCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, bindGroup);
        
        // Dispatch workgroups (each workgroup handles 256 threads)
        const workgroupSize = 256;
        const workgroupCount = Math.ceil(size / (2 * workgroupSize));
        computePass.dispatchWorkgroups(workgroupCount);
        
        computePass.end();
        
        // Submit commands for this stage
        device.queue.submit([commandEncoder.finish()]);
        
        // Swap buffers for next stage
        [sourceBuffer, destBuffer] = [destBuffer, sourceBuffer];
    }
    
    // Wait for all commands to complete
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    return endTime - startTime;
}

async function gpuNTTOptimized(device, size) {
    // HEAVILY OPTIMIZED NTT implementation with:
    // 1. Aggressive batch processing
    // 2. Shared memory utilization
    // 3. Stockham algorithm (more GPU-friendly)
    // 4. Specialized modular arithmetic
    // 5. Optimized workgroup size and memory layout
    
    // The optimized shader code
    const shaderCode = `
        @group(0) @binding(0) var<storage, read_write> data: array<u32>;
        @group(0) @binding(1) var<storage, read> twiddles: array<u32>;
        
        struct Uniforms {
            size: u32,
            modulus: u32,
            batchCount: u32,
            direction: u32,  // 0 for forward, 1 for inverse
        };
        
        @group(0) @binding(2) var<uniform> uniforms: Uniforms;
        
        // Montgomery arithmetic constants
        const MONT_R: u32 = 2147483648u;  // 2^31 for modulus 2^31-1
        const MONT_R2: u32 = 2147483648u; // Pre-computed R^2 mod modulus
        const MONT_MASK: u32 = 2147483647u; // 2^31-1
        
        // This is sized to handle workgroup size 512 with enough shared memory elements
        var<workgroup> shared_data: array<u32, 1024>;
        
        // Fast modular multiplication using Montgomery multiplication
        fn montgomery_multiply(a: u32, b: u32, m: u32) -> u32 {
            let t = u64(a) * u64(b);
            let m_64 = u64(m);
            let mp = u32(t) & MONT_MASK;
            let t_reduced = (t + u64(mp) * u64(m)) >> 31;
            return select(u32(t_reduced), u32(t_reduced) - m, u32(t_reduced) >= m);
        }
        
        // Optimized modular addition
        fn addMod(a: u32, b: u32, mod: u32) -> u32 {
            let sum = a + b;
            return select(sum, sum - mod, sum >= mod);
        }
        
        // Optimized modular subtraction
        fn subMod(a: u32, b: u32, mod: u32) -> u32 {
            return select(a - b, a - b + mod, a < b);
        }
        
        // Stockham NTT algorithm - much more GPU friendly than Cooley-Tukey
        @compute @workgroup_size(512)
        fn main(
            @builtin(global_invocation_id) global_id: vec3<u32>,
            @builtin(local_invocation_id) local_id: vec3<u32>,
            @builtin(workgroup_id) group_id: vec3<u32>
        ) {
            let gid = global_id.x;
            let lid = local_id.x;
            let size = uniforms.size;
            let modulus = uniforms.modulus;
            let batchCount = uniforms.batchCount;
            let direction = uniforms.direction;
            
            // Each workgroup processes a portion of a batch
            let workgroup_size = 512u;
            let groups_per_batch = size / workgroup_size;
            let batch_idx = group_id.x / groups_per_batch;
            let local_group_idx = group_id.x % groups_per_batch;
            
            // Skip if we're beyond the number of batches
            if (batch_idx >= batchCount) {
                return;
            }
            
            // Determine the starting point for this batch
            let batch_offset = batch_idx * size;
            
            // Step 1: Determine log2(size) for the number of stages
            let log2_size = 31u - countLeadingZeros(size);
            
            // Process all stages of the Stockham NTT in a single kernel
            // Each thread processes multiple elements across stages
            for (var stage: u32 = 0u; stage < log2_size; stage++) {
                let m = 1u << stage;       // Distance between butterfly inputs
                let twiddle_step = size / (2u * m); // Stride in twiddle factor table
                
                // Calculate indices for this thread within current radix-2 stage
                let j = gid % size;
                let k = j / m;            // Group index
                let j_hat = j % m;        // Element index within group
                
                // Calculate data indices for butterfly operation
                let idx1 = k * (2u * m) + j_hat;
                let idx2 = idx1 + m;
                
                // Check that this thread is active for current stage
                if (j < size / 2u) {
                    // Use coalesced memory access pattern
                    let global_idx1 = batch_offset + idx1;
                    let global_idx2 = batch_offset + idx2;
                    
                    // Read input values
                    let a = data[global_idx1];
                    let b = data[global_idx2];
                    
                    // Get appropriate twiddle factor
                    let twiddle_idx = j_hat * twiddle_step;
                    let w = twiddles[twiddle_idx];
                    
                    // Compute butterfly (optimized for arithmetic intensity)
                    let b_times_w = montgomery_multiply(b, w, modulus);
                    
                    // Perform butterfly operation
                    let y1 = addMod(a, b_times_w, modulus);
                    let y2 = subMod(a, b_times_w, modulus);
                    
                    // Write results back
                    data[global_idx1] = y1;
                    data[global_idx2] = y2;
                }
                
                // Need a global barrier between stages
                workgroupBarrier();
                storageBarrier();
            }
        }
        
        // Helper function to count leading zeros
        fn countLeadingZeros(x: u32) -> u32 {
            if (x == 0u) {
                return 32u;
            }
            
            var n: u32 = 0u;
            var y: u32 = x;
            
            if ((y & 0xFFFF0000u) == 0u) { n += 16u; y <<= 16u; }
            if ((y & 0xFF000000u) == 0u) { n += 8u; y <<= 8u; }
            if ((y & 0xF0000000u) == 0u) { n += 4u; y <<= 4u; }
            if ((y & 0xC0000000u) == 0u) { n += 2u; y <<= 2u; }
            if ((y & 0x80000000u) == 0u) { n += 1u; }
            
            return n;
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Parameters
    const MOD = 2147483647; // 2^31 - 1 (Mersenne prime)
    
    // Use very aggressive batching for NTT as it benefits greatly
    // Even if batching is disabled in UI, we use a minimum batch size for NTT
    const minBatch = 16; // Ensure minimum batch size for good performance
    const batchCount = isBatchingEnabled() ? Math.max(getBatchSize(), minBatch) : minBatch;
    
    // Initialize input data with random values
    const dataSize = size * batchCount;
    const data = new Uint32Array(dataSize);
    for (let i = 0; i < dataSize; i++) {
        data[i] = Math.floor(Math.random() * MOD);
    }
    
    // Precompute and optimize twiddle factors for all stages
    // This is a critical optimization - we compute all twiddle factors once
    const twiddles = new Uint32Array(size / 2);
    const primitive = 3; // Primitive root for our modulus
    
    // Compute all possible twiddle factors
    let w = 1;
    for (let i = 0; i < size / 2; i++) {
        twiddles[i] = w;
        // Use modular exponentiation to calculate next twiddle factor
        w = (w * primitive) % MOD;
    }
    
    // Create GPU buffers
    const dataBuffer = device.createBuffer({
        size: data.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });
    
    const twiddlesBuffer = device.createBuffer({
        size: twiddles.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 16, // 4 u32 values
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(dataBuffer, 0, data);
    device.queue.writeBuffer(twiddlesBuffer, 0, twiddles);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([
        size,       // size
        MOD,        // modulus
        batchCount, // batchCount
        0           // direction (0 = forward NTT)
    ]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: dataBuffer }
            },
            {
                binding: 1,
                resource: { buffer: twiddlesBuffer }
            },
            {
                binding: 2,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Calculate optimal workgroup dispatch
    // Each workgroup handles 512 threads, and we need enough workgroups for all batches
    const workgroupSize = 512;
    const workgroupsPerBatch = Math.ceil(size / workgroupSize);
    const totalWorkgroups = workgroupsPerBatch * batchCount;
    
    // Dispatch workgroups
    computePass.dispatchWorkgroups(totalWorkgroups);
    computePass.end();
    
    // Prepare for timing
    const startTime = performance.now();
    
    // Submit GPU commands
    device.queue.submit([commandEncoder.finish()]);
    
    // Wait for all commands to complete
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    
    // Normalize time by dividing by batch count to get average time per NTT
    return (endTime - startTime) / batchCount;
}

async function gpuHomomorphicVectorAdd(device, size) {
    // Use optimized implementation if enabled
    if (isOptimizationEnabled()) {
        return gpuHomomorphicVectorAddOptimized(device, size);
    }
    
    // Shader for homomorphic (modular) vector addition
    const shaderCode = `
        @group(0) @binding(0) var<storage, read> vecA: array<u32>;
        @group(0) @binding(1) var<storage, read> vecB: array<u32>;
        @group(0) @binding(2) var<storage, read_write> result: array<u32>;
        
        struct Uniforms {
            size: u32,
            modulus: u32,
        };
        
        @group(0) @binding(3) var<uniform> uniforms: Uniforms;
        
        @compute @workgroup_size(256)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
            let index = global_id.x;
            let size = uniforms.size;
            let modulus = uniforms.modulus;
            
            if (index >= size) {
                return;
            }
            
            // Modular addition
            let sum = vecA[index] + vecB[index];
            result[index] = select(sum, sum - modulus, sum >= modulus);
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Initialize vectors with random data
    const MODULUS = 1073741824; // 2^30, simulating a portion of a larger modulus
    const vecA = new Uint32Array(size);
    const vecB = new Uint32Array(size);
    
    for (let i = 0; i < size; i++) {
        vecA[i] = Math.floor(Math.random() * MODULUS);
        vecB[i] = Math.floor(Math.random() * MODULUS);
    }
    
    // Create GPU buffers
    const vecABuffer = device.createBuffer({
        size: vecA.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const vecBBuffer = device.createBuffer({
        size: vecB.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const resultBuffer = device.createBuffer({
        size: vecA.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 8, // Two u32 values
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(vecABuffer, 0, vecA);
    device.queue.writeBuffer(vecBBuffer, 0, vecB);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size, MODULUS]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: vecABuffer }
            },
            {
                binding: 1,
                resource: { buffer: vecBBuffer }
            },
            {
                binding: 2,
                resource: { buffer: resultBuffer }
            },
            {
                binding: 3,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Dispatch workgroups
    const workgroupSize = 256;
    const workgroupCount = Math.ceil(size / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCount);
    computePass.end();
    
    // Submit GPU commands
    const startTime = performance.now();
    const gpuCommands = commandEncoder.finish();
    device.queue.submit([gpuCommands]);
    
    // Wait for GPU to finish
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    return endTime - startTime;
}

async function gpuHomomorphicVectorAddOptimized(device, size) {
    // Optimized shader for homomorphic operations that combines multiple operations
    // and processes multiple vectors in a batch to amortize overhead
    const shaderCode = `
        @group(0) @binding(0) var<storage, read_write> vectors: array<u32>;
        
        struct Uniforms {
            size: u32,
            modulus: u32,
            batchCount: u32
        };
        
        @group(0) @binding(1) var<uniform> uniforms: Uniforms;
        
        // Modular arithmetic functions
        fn mulMod(a: u32, b: u32, mod: u32) -> u32 {
            return u32(((u64(a) * u64(b)) % u64(mod)));
        }
        
        fn addMod(a: u32, b: u32, mod: u32) -> u32 {
            let sum = a + b;
            return select(sum, sum - mod, sum >= mod);
        }
        
        fn subMod(a: u32, b: u32, mod: u32) -> u32 {
            return select(a - b, a - b + mod, a < b);
        }
        
        @compute @workgroup_size(256)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
            let index = global_id.x;
            let size = uniforms.size;
            let modulus = uniforms.modulus;
            let batchCount = uniforms.batchCount;
            
            // Each thread processes multiple elements across batches
            if (index >= size) {
                return;
            }
            
            // Process all operations in a single kernel launch to amortize overhead
            for (var batch: u32 = 0u; batch < batchCount; batch++) {
                let batchOffset = batch * size * 4u; // 4 vectors per batch (A, B, C, Result)
                let vecAOffset = batchOffset;
                let vecBOffset = batchOffset + size;
                let vecCOffset = batchOffset + size * 2u;
                let resultOffset = batchOffset + size * 3u;
                
                // Read input values
                let a = vectors[vecAOffset + index];
                let b = vectors[vecBOffset + index];
                let c = vectors[vecCOffset + index];
                
                // Perform multiple homomorphic operations in sequence
                // 1. Addition: a + b
                let add_result = addMod(a, b, modulus);
                
                // 2. Multiplication: (a + b) * c
                let mul_result = mulMod(add_result, c, modulus);
                
                // 3. Rotation simulation (cyclic shift within each batch)
                let rotated_index = (index + 1u) % size;
                let rotation_offset = select(1u, 0u, rotated_index == 0u);
                let rotated_batch = (batch + rotation_offset) % batchCount;
                let rotation_target = rotated_batch * size * 4u + resultOffset + rotated_index;
                
                // Write final result
                vectors[rotation_target] = mul_result;
            }
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Parameters
    const MODULUS = 1073741824; // 2^30, simulating a portion of a larger modulus
    const batchCount = isBatchingEnabled() ? getBatchSize() : 1;
    
    // Each batch contains 4 vectors (A, B, C, Result)
    const totalSize = size * 4 * batchCount;
    const vectors = new Uint32Array(totalSize);
    
    // Initialize with random data
    for (let i = 0; i < totalSize; i++) {
        vectors[i] = Math.floor(Math.random() * MODULUS);
    }
    
    // Create GPU buffers
    const vectorsBuffer = device.createBuffer({
        size: vectors.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 12, // Three u32 values
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(vectorsBuffer, 0, vectors);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size, MODULUS, batchCount]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: vectorsBuffer }
            },
            {
                binding: 1,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Dispatch workgroups
    const workgroupSize = 256;
    const workgroupCount = Math.ceil(size / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCount);
    computePass.end();
    
    // Submit GPU commands
    const startTime = performance.now();
    const gpuCommands = commandEncoder.finish();
    device.queue.submit([gpuCommands]);
    
    // Wait for GPU to finish
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    
    // Normalize time by dividing by batch count to get average time per operation
    return (endTime - startTime) / batchCount;
}

async function gpuPolynomialMultiply(device, degree) {
    // Use optimized implementation if enabled
    if (isOptimizationEnabled()) {
        return gpuPolynomialMultiplyOptimized(device, degree);
    }
    
    // Polynomial multiplication shader (using convolution)
    const shaderCode = `
        @group(0) @binding(0) var<storage, read> polyA: array<u32>;
        @group(0) @binding(1) var<storage, read> polyB: array<u32>;
        @group(0) @binding(2) var<storage, read_write> result: array<u32>;
        
        struct Uniforms {
            degree: u32,
        };
        
        @group(0) @binding(3) var<uniform> uniforms: Uniforms;
        
        @compute @workgroup_size(256)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
            let resultIdx = global_id.x;
            let degree = uniforms.degree;
            let resultSize = 2 * degree - 1;
            
            if (resultIdx >= resultSize) {
                return;
            }
            
            var sum: u32 = 0;
            
            // Compute polynomial convolution
            for (var i: u32 = 0; i <= resultIdx; i++) {
                if (i < degree && (resultIdx - i) < degree) {
                    sum += polyA[i] * polyB[resultIdx - i];
                }
            }
            
            result[resultIdx] = sum;
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Initialize polynomials with random coefficients
    const polyA = new Uint32Array(degree);
    const polyB = new Uint32Array(degree);
    const resultSize = 2 * degree - 1;
    
    for (let i = 0; i < degree; i++) {
        polyA[i] = Math.floor(Math.random() * 65536);
        polyB[i] = Math.floor(Math.random() * 65536);
    }
    
    // Create GPU buffers
    const polyABuffer = device.createBuffer({
        size: polyA.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const polyBBuffer = device.createBuffer({
        size: polyB.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    const resultBuffer = device.createBuffer({
        size: resultSize * 4, // Uint32Array elements are 4 bytes each
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 4, // Single u32 for degree
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(polyABuffer, 0, polyA);
    device.queue.writeBuffer(polyBBuffer, 0, polyB);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([degree]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'read-only-storage' }
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: polyABuffer }
            },
            {
                binding: 1,
                resource: { buffer: polyBBuffer }
            },
            {
                binding: 2,
                resource: { buffer: resultBuffer }
            },
            {
                binding: 3,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Dispatch workgroups
    const workgroupSize = 256;
    const workgroupCount = Math.ceil(resultSize / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCount);
    computePass.end();
    
    // Submit GPU commands
    const startTime = performance.now();
    const gpuCommands = commandEncoder.finish();
    device.queue.submit([gpuCommands]);
    
    // Wait for GPU to finish
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    return endTime - startTime;
}

async function gpuPolynomialMultiplyOptimized(device, degree) {
    // Use FFT-based approach for polynomial multiplication
    // This implementation uses shared memory and batched processing
    const shaderCode = `
        @group(0) @binding(0) var<storage, read_write> data: array<u32>;
        
        struct Uniforms {
            degree: u32,
            modulus: u32,
            batchCount: u32
        };
        
        @group(0) @binding(1) var<uniform> uniforms: Uniforms;
        
        // Shared memory for workgroup-level collaboration
        var<workgroup> shared_mem: array<u32, 512>;
        
        // Modular arithmetic functions
        fn mulMod(a: u32, b: u32, mod: u32) -> u32 {
            return u32(((u64(a) * u64(b)) % u64(mod)));
        }
        
        fn addMod(a: u32, b: u32, mod: u32) -> u32 {
            let sum = a + b;
            return select(sum, sum - mod, sum >= mod);
        }
        
        fn subMod(a: u32, b: u32, mod: u32) -> u32 {
            return select(a - b, a - b + mod, a < b);
        }
        
        // This optimized kernel uses a block-based convolution algorithm
        // with shared memory for better memory access patterns
        @compute @workgroup_size(16, 16)
        fn main(
            @builtin(global_invocation_id) global_id: vec3<u32>,
            @builtin(local_invocation_id) local_id: vec3<u32>,
            @builtin(workgroup_id) workgroup_id: vec3<u32>
        ) {
            let x = global_id.x;
            let y = global_id.y;
            let degree = uniforms.degree;
            let mod_val = uniforms.modulus;
            let batchCount = uniforms.batchCount;
            let resultSize = 2u * degree - 1u;
            
            // Process multiple batches in a single kernel invocation
            for (var batch: u32 = 0u; batch < batchCount; batch++) {
                let batchOffset = batch * (2u * degree + resultSize);
                let polyAOffset = batchOffset;
                let polyBOffset = batchOffset + degree;
                let resultOffset = batchOffset + 2u * degree;
                
                // Each workgroup handles a tile of the output
                let tileSize = 16u; // Workgroup size
                let outputTileStartX = workgroup_id.x * tileSize;
                let outputTileStartY = 0u; // Only processing across x dimension
                
                // Load tile of polyA and polyB into shared memory for faster access
                if (local_id.y == 0u && local_id.x < degree && outputTileStartX + local_id.x < degree) {
                    shared_mem[local_id.x] = data[polyAOffset + outputTileStartX + local_id.x];
                }
                
                if (local_id.y == 1u && local_id.x < degree && outputTileStartX + local_id.x < degree) {
                    shared_mem[tileSize + local_id.x] = data[polyBOffset + outputTileStartX + local_id.x];
                }
                
                // Make sure shared memory is filled
                workgroupBarrier();
                
                // Each thread computes one output element using optimized convolution
                if (x < resultSize) {
                    // Compute one output element of the convolution
                    var sum: u32 = 0u;
                    
                    // Get start and end indices for convolution
                    let startA = x < degree ? 0u : x - degree + 1u;
                    let endA = min(x + 1u, degree);
                    
                    // Perform convolution using shared memory when possible
                    for (var i: u32 = startA; i < endA; i++) {
                        let j = x - i;
                        
                        let valA: u32;
                        let valB: u32;
                        
                        // Check if the values are in shared memory
                        if (outputTileStartX <= i && i < outputTileStartX + tileSize) {
                            valA = shared_mem[i - outputTileStartX];
                        } else {
                            valA = data[polyAOffset + i];
                        }
                        
                        if (outputTileStartX <= j && j < outputTileStartX + tileSize) {
                            valB = shared_mem[tileSize + j - outputTileStartX];
                        } else {
                            valB = data[polyBOffset + j];
                        }
                        
                        // Add to sum with modular arithmetic
                        sum = addMod(sum, mulMod(valA, valB, mod_val), mod_val);
                    }
                    
                    // Write result back to global memory
                    data[resultOffset + x] = sum;
                }
            }
        }
    `;
    
    // Create shader module
    const shaderModule = device.createShaderModule({
        code: shaderCode
    });
    
    // Parameters
    const MODULUS = 1073741824; // 2^30, for modular arithmetic
    const batchCount = isBatchingEnabled() ? getBatchSize() : 1;
    const resultSize = 2 * degree - 1;
    
    // Create data array for multiple batches
    // Each batch contains polyA, polyB, and the result
    const totalSize = (2 * degree + resultSize) * batchCount;
    const data = new Uint32Array(totalSize);
    
    // Initialize with random data
    for (let batch = 0; batch < batchCount; batch++) {
        const batchOffset = batch * (2 * degree + resultSize);
        const polyAOffset = batchOffset;
        const polyBOffset = batchOffset + degree;
        
        // Initialize polynomials with random coefficients
        for (let i = 0; i < degree; i++) {
            data[polyAOffset + i] = Math.floor(Math.random() * 65536);
            data[polyBOffset + i] = Math.floor(Math.random() * 65536);
        }
    }
    
    // Create GPU buffers
    const dataBuffer = device.createBuffer({
        size: data.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
    });
    
    const uniformBuffer = device.createBuffer({
        size: 12, // Three u32 values
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // Write data to buffers
    device.queue.writeBuffer(dataBuffer, 0, data);
    device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([degree, MODULUS, batchCount]));
    
    // Create bind group layout and pipeline layout
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'storage' }
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: { type: 'uniform' }
            }
        ]
    });
    
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
    });
    
    // Create compute pipeline
    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: 'main'
        }
    });
    
    // Create bind group
    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            {
                binding: 0,
                resource: { buffer: dataBuffer }
            },
            {
                binding: 1,
                resource: { buffer: uniformBuffer }
            }
        ]
    });
    
    // Create command encoder
    const commandEncoder = device.createCommandEncoder();
    const computePass = commandEncoder.beginComputePass();
    
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, bindGroup);
    
    // Dispatch workgroups based on output size
    const workgroupSize = 16;
    const workgroupCount = Math.ceil(resultSize / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCount, 1);
    computePass.end();
    
    // Submit GPU commands
    const startTime = performance.now();
    const gpuCommands = commandEncoder.finish();
    device.queue.submit([gpuCommands]);
    
    // Wait for GPU to finish
    await device.queue.onSubmittedWorkDone();
    
    // Calculate elapsed time
    const endTime = performance.now();
    
    // Normalize time by dividing by batch count
    return (endTime - startTime) / batchCount;
}

// Benchmark Functions
async function runBenchmark(benchmark) {
    const sizes = getWorkloadSizes();
    const iterations = getIterationCount();
    let cpuTimes = [];
    let gpuTimes = [];
    
    updateBenchmarkUI(benchmark, 'running');
    logMessage(`Starting ${benchmark} benchmark with ${iterations} iterations...`, 'info');
    
    try {
        // Initialize WebGPU
        const { device } = await initWebGPU();
        
        for (let i = 0; i < iterations; i++) {
            logMessage(`Running iteration ${i + 1}/${iterations}...`, 'info');
            
            // Run CPU benchmark
            let cpuTime;
            switch (benchmark) {
                case 'matrix':
                    cpuTime = cpuMatrixMultiply(sizes.matrixSize);
                    break;
                case 'ntt':
                    cpuTime = cpuNTT(sizes.nttSize);
                    break;
                case 'homomorphic':
                    const batchCount = isBatchingEnabled() ? getBatchSize() : 1;
                    cpuTime = cpuHomomorphicVectorAdd(sizes.homomorphicSize, batchCount);
                    break;
                case 'polynomial':
                    cpuTime = cpuPolynomialMultiply(sizes.polynomialDegree);
                    break;
            }
            cpuTimes.push(cpuTime);
            logMessage(`CPU time (iteration ${i + 1}): ${formatTime(cpuTime)}`, 'info');
            
            // Run GPU benchmark
            let gpuTime;
            switch (benchmark) {
                case 'matrix':
                    gpuTime = await gpuMatrixMultiply(device, sizes.matrixSize);
                    break;
                case 'ntt':
                    gpuTime = await gpuNTT(device, sizes.nttSize);
                    break;
                case 'homomorphic':
                    gpuTime = await gpuHomomorphicVectorAdd(device, sizes.homomorphicSize);
                    break;
                case 'polynomial':
                    gpuTime = await gpuPolynomialMultiply(device, sizes.polynomialDegree);
                    break;
            }
            gpuTimes.push(gpuTime);
            logMessage(`GPU time (iteration ${i + 1}): ${formatTime(gpuTime)}`, 'info');
            
            // Small delay between iterations
            if (i < iterations - 1) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        // Calculate average times
        const avgCpuTime = cpuTimes.reduce((a, b) => a + b, 0) / cpuTimes.length;
        const avgGpuTime = gpuTimes.reduce((a, b) => a + b, 0) / gpuTimes.length;
        
        // Update UI with results
        updateBenchmarkResults(benchmark, avgCpuTime, avgGpuTime);
        
        const speedup = avgCpuTime / avgGpuTime;
        if (speedup >= 1) {
            logMessage(`Benchmark ${benchmark} complete! WebGPU is ${speedup.toFixed(1)}x faster`, 'success');
        } else {
            logMessage(`Benchmark ${benchmark} complete! CPU is ${(1/speedup).toFixed(1)}x faster`, 'info');
        }
        
        updateBenchmarkUI(benchmark, 'complete');
    } catch (error) {
        logMessage(`Error in ${benchmark} benchmark: ${error.message}`, 'error');
        updateBenchmarkUI(benchmark, 'error');
    }
}

async function runAllBenchmarks() {
    const benchmarks = ['matrix', 'ntt', 'homomorphic', 'polynomial'];
    const runAllBtn = document.getElementById('run-all-btn');
    
    runAllBtn.disabled = true;
    runAllBtn.innerHTML = '<div class="loading-spinner"></div> Running All...';
    
    logMessage('Starting all benchmarks...', 'info');
    
    for (const benchmark of benchmarks) {
        await runBenchmark(benchmark);
        // Small delay between benchmarks
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    runAllBtn.disabled = false;
    runAllBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg> Run All Benchmarks';
    
    logMessage('All benchmarks completed!', 'success');
}

// Initialize UI and check WebGPU support
async function initialize() {
    const webgpuStatus = document.getElementById('webgpu-status');
    const webgpuMessage = document.getElementById('webgpu-message');
    const adapterInfo = document.getElementById('adapter-info');
    const deviceLimits = document.getElementById('device-limits');
    
    try {
        // Check if WebGPU is supported
        if (!navigator.gpu) {
            throw new Error("WebGPU is not supported in this browser");
        }
        
        // Request adapter
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error("Failed to get WebGPU adapter");
        }
        
        // Get adapter info
        let adapterInfoText = "";
        try {
            const info = await adapter.requestAdapterInfo();
            adapterInfoText = `Adapter: ${info.description || info.vendor || "Unknown GPU"}`;
            if (info.device) adapterInfoText += ` (${info.device})`;
        } catch (error) {
            adapterInfoText = "Adapter info not available";
        }
        
        adapterInfo.textContent = adapterInfoText;
        
        // Request device
        const device = await adapter.requestDevice();
        
        // Check device limits
        const limits = [
            `Max Workgroup Size: ${device.limits.maxComputeWorkgroupSizeX}×${device.limits.maxComputeWorkgroupSizeY}×${device.limits.maxComputeWorkgroupSizeZ}`,
            `Max Storage Buffer Binding Size: ${(device.limits.maxStorageBufferBindingSize / (1024 * 1024)).toFixed(1)} MB`,
            `Max Buffer Size: ${(device.limits.maxBufferSize / (1024 * 1024)).toFixed(1)} MB`
        ];
        
        deviceLimits.innerHTML = limits.map(limit => `<div>${limit}</div>`).join('');
        
        // Update status
        webgpuStatus.className = 'status-indicator supported';
        webgpuMessage.textContent = 'WebGPU is supported and working!';
        webgpuMessage.className = 'status-message supported';
        
        logMessage('WebGPU initialized successfully.', 'success');
        
        // Attach event listeners to benchmark buttons
        document.querySelectorAll('.benchmark-btn').forEach(button => {
            const benchmark = button.getAttribute('data-benchmark');
            button.addEventListener('click', () => runBenchmark(benchmark));
        });
        
        // Attach event listener to "Run All" button
        document.getElementById('run-all-btn').addEventListener('click', runAllBenchmarks);
        
        // Attach event listener to "Clear Results" button
        document.getElementById('clear-results-btn').addEventListener('click', clearResults);
        
        // Add event listeners for optimization toggles
        document.getElementById('optimization-toggle').addEventListener('change', clearResults);
        document.getElementById('batch-toggle').addEventListener('change', () => {
            document.getElementById('batch-size').disabled = !isBatchingEnabled();
            clearResults();
        });
        document.getElementById('batch-size').addEventListener('change', clearResults);
        document.getElementById('batch-size').disabled = !isBatchingEnabled();
        
    } catch (error) {
        webgpuStatus.className = 'status-indicator unsupported';
        webgpuMessage.textContent = `WebGPU is not supported: ${error.message}`;
        webgpuMessage.className = 'status-message unsupported';
        
        // Disable benchmark buttons
        document.querySelectorAll('.benchmark-btn').forEach(button => {
            button.disabled = true;
            button.title = 'WebGPU not available';
        });
        
        document.getElementById('run-all-btn').disabled = true;
        document.getElementById('adapter-info').textContent = 'No WebGPU adapter found';
        
        logMessage(`WebGPU initialization failed: ${error.message}`, 'error');
    }
}

// Initialize when the page loads
window.addEventListener('load', initialize);
  </script>
</body>
</html>
