<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Post-Quantum Cryptography Benchmark</title>
    <style>
        :root {
            --primary: #6200EA;
            --primary-light: #9d46ff;
            --secondary: #03DAC6;
            --dark: #121212;
            --light: #f5f5f5;
            --error: #ff4444;
            --warning: #ffbb33;
            --success: #00C851;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--dark);
            color: var(--light);
            line-height: 1.6;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-top: 0.5rem;
        }
        
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--primary);
        }
        
        .status-container {
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-indicator.supported {
            background-color: var(--success);
        }
        
        .status-indicator.unsupported {
            background-color: var(--error);
        }
        
        .status-message {
            font-weight: 500;
        }
        
        .supported {
            color: var(--success);
        }
        
        .unsupported {
            color: var(--error);
        }
        
        .warning {
            color: var(--warning);
        }
        
        .benchmark-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        button:hover {
            background-color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        button.running {
            background-color: var(--warning);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 1;
            }
        }
        
        select, input {
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            font-size: 1rem;
        }
        
        .benchmark-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .benchmark-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .benchmark-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }
        
        .benchmark-title {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            color: var(--secondary);
        }
        
        .benchmark-description {
            color: #ccc;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .result-container {
            margin-top: 1.5rem;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .result-label {
            font-weight: 500;
        }
        
        .result-value {
            font-family: monospace;
            font-size: 1.1rem;
        }
        
        .speedup-text {
            font-weight: bold;
            font-size: 1.1rem;
            margin-top: 1rem;
            padding: 0.5rem;
            text-align: center;
            background-color: rgba(0, 200, 81, 0.1);
            border-radius: 4px;
        }
        
        .chart-container {
            margin-top: 1rem;
            height: 180px;
            position: relative;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(18, 18, 18, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(3px);
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--secondary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .log-container {
            margin-top: 2rem;
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
        }
        
        .log-entry.info {
            color: #63B1FF;
        }
        
        .log-entry.error {
            color: var(--error);
        }
        
        .log-entry.success {
            color: var(--success);
        }
        
        .log-time {
            color: #888;
            margin-right: 0.5rem;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 2rem;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
            color: #999;
        }
        
        .chart-bar {
            position: relative;
            height: 30px;
            margin: 8px 0;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .chart-label {
            position: absolute;
            left: 10px;
            top: 5px;
            z-index: 1;
            font-size: 0.8rem;
        }
        
        .chart-fill {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
            transition: width 1s ease-out;
        }
        
        .chart-fill.cpu {
            background-color: var(--primary);
            width: 0%;
        }
        
        .chart-fill.gpu {
            background-color: var(--secondary);
            width: 0%;
        }
        
        @media (max-width: 768px) {
            main {
                padding: 1rem;
            }
            
            header {
                padding: 1.5rem 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .benchmark-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>WebGPU Post-Quantum Cryptography Benchmark</h1>
        <div class="subtitle">Evaluating GPU acceleration for quantum-resistant algorithms</div>
    </header>
    
    <main>
        <div class="card">
            <h2>System Capabilities</h2>
            <div class="status-container">
                <div>
                    <span class="status-indicator" id="webgpu-status"></span>
                    <span class="status-message" id="webgpu-message">Checking WebGPU support...</span>
                </div>
                <div id="adapter-info"></div>
            </div>
            <div id="device-limits" class="status-container"></div>
        </div>
        
        <div class="card">
            <h2>Benchmark Controls</h2>
            <div class="benchmark-controls">
                <select id="workload-size">
                    <option value="small">Small (Fast)</option>
                    <option value="medium" selected>Medium (Balanced)</option>
                    <option value="large">Large (Intensive)</option>
                    <option value="extreme">Extreme (May crash browser)</option>
                </select>
                
                <select id="iteration-count">
                    <option value="1">1 Iteration</option>
                    <option value="3" selected>3 Iterations</option>
                    <option value="5">5 Iterations</option>
                    <option value="10">10 Iterations</option>
                </select>
                
                <button id="run-all-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="13 17 18 12 13 7"></polyline>
                        <polyline points="6 17 11 12 6 7"></polyline>
                    </svg>
                    Run All Benchmarks
                </button>
                
                <button id="clear-results-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Clear Results
                </button>
            </div>
            
            <div class="benchmark-grid">
                <div class="benchmark-card">
                    <h3 class="benchmark-title">Matrix Multiplication</h3>
                    <div class="benchmark-description">Core operation for lattice-based cryptography and neural network processing.</div>
                    
                    <button class="benchmark-btn" data-benchmark="matrix">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="matrix"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="matrix"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="matrix-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="matrix-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="matrix-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card">
                    <h3 class="benchmark-title">NTT (Number Theoretic Transform)</h3>
                    <div class="benchmark-description">Essential for lattice-based schemes like Kyber and Dilithium.</div>
                    
                    <button class="benchmark-btn" data-benchmark="ntt">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="ntt"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="ntt"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="ntt-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="ntt-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="ntt-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card">
                    <h3 class="benchmark-title">Homomorphic Vector Addition</h3>
                    <div class="benchmark-description">Fundamental operation for homomorphic encryption (CKKS scheme).</div>
                    
                    <button class="benchmark-btn" data-benchmark="homomorphic">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="homomorphic"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="homomorphic"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="homomorphic-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="homomorphic-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="homomorphic-speedup">Run benchmark to see results</div>
                    </div>
                </div>
                
                <div class="benchmark-card">
                    <h3 class="benchmark-title">Polynomial Multiplication</h3>
                    <div class="benchmark-description">Key operation in Ring-LWE based cryptography.</div>
                    
                    <button class="benchmark-btn" data-benchmark="polynomial">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Run Benchmark
                    </button>
                    
                    <div class="result-container">
                        <div class="chart-container">
                            <div class="chart-bar">
                                <span class="chart-label">CPU</span>
                                <div class="chart-fill cpu" data-benchmark="polynomial"></div>
                            </div>
                            <div class="chart-bar">
                                <span class="chart-label">GPU</span>
                                <div class="chart-fill gpu" data-benchmark="polynomial"></div>
                            </div>
                        </div>
                        <div class="result-row">
                            <span class="result-label">CPU Time:</span>
                            <span class="result-value" id="polynomial-cpu">-</span>
                        </div>
                        <div class="result-row">
                            <span class="result-label">GPU Time:</span>
                            <span class="result-value" id="polynomial-gpu">-</span>
                        </div>
                        <div class="speedup-text" id="polynomial-speedup">Run benchmark to see results</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Execution Log</h2>
            <div class="log-container" id="log-container"></div>
        </div>
    </main>
    
    <footer>
        <p>WebGPU Post-Quantum Cryptography Benchmark Tool • 2025</p>
        <p>For demonstration purposes only. Results may vary based on hardware, drivers, and browser implementation.</p>
    </footer>
    
    <script>
        // Utility Functions
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            
            logEntry.innerHTML = `<span class="log-time">[${timeStr}]</span> ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function formatTime(ms) {
            if (ms < 1) {
                return `${(ms * 1000).toFixed(2)} µs`;
            } else if (ms < 1000) {
                return `${ms.toFixed(2)} ms`;
            } else {
                return `${(ms / 1000).toFixed(2)} s`;
            }
        }
        
        function getWorkloadSizes() {
            const sizeOption = document.getElementById('workload-size').value;
            
            switch (sizeOption) {
                case 'small':
                    return {
                        matrixSize: 512,
                        nttSize: 1024,
                        homomorphicSize: 4096,
                        polynomialDegree: 512
                    };
                case 'medium':
                    return {
                        matrixSize: 1024,
                        nttSize: 2048,
                        homomorphicSize: 8192,
                        polynomialDegree: 1024
                    };
                case 'large':
                    return {
                        matrixSize: 2048,
                        nttSize: 4096,
                        homomorphicSize: 16384,
                        polynomialDegree: 2048
                    };
                case 'extreme':
                    return {
                        matrixSize: 4096,
                        nttSize: 8192,
                        homomorphicSize: 32768,
                        polynomialDegree: 4096
                    };
                default:
                    return {
                        matrixSize: 1024,
                        nttSize: 2048,
                        homomorphicSize: 8192,
                        polynomialDegree: 1024
                    };
            }
        }
        
        function getIterationCount() {
            return parseInt(document.getElementById('iteration-count').value);
        }
        
        function updateBenchmarkUI(benchmark, state) {
            const buttons = document.querySelectorAll(`.benchmark-btn[data-benchmark="${benchmark}"]`);
            buttons.forEach(button => {
                if (state === 'running') {
                    button.disabled = true;
                    button.classList.add('running');
                    button.innerHTML = '<div class="loading-spinner"></div> Running...';
                } else if (state === 'complete') {
                    button.disabled = false;
                    button.classList.remove('running');
                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Run Again';
                } else {
                    button.disabled = false;
                    button.classList.remove('running');
                    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Run Benchmark';
                }
            });
        }
        
        function updateBenchmarkResults(benchmark, cpuTime, gpuTime) {
            document.getElementById(`${benchmark}-cpu`).textContent = formatTime(cpuTime);
            document.getElementById(`${benchmark}-gpu`).textContent = formatTime(gpuTime);
            
            const speedup = cpuTime / gpuTime;
            const speedupElement = document.getElementById(`${benchmark}-speedup`);
            
            if (speedup >= 1) {
                speedupElement.textContent = `WebGPU is ${speedup.toFixed(1)}x faster`;
                speedupElement.style.backgroundColor = 'rgba(0, 200, 81, 0.1)';
            } else {
                speedupElement.textContent = `CPU is ${(1/speedup).toFixed(1)}x faster`;
                speedupElement.style.backgroundColor = 'rgba(255, 68, 68, 0.1)';
            }
            
            // Update chart bars
            const maxTime = Math.max(cpuTime, gpuTime);
            const cpuBar = document.querySelector(`.chart-fill.cpu[data-benchmark="${benchmark}"]`);
            const gpuBar = document.querySelector(`.chart-fill.gpu[data-benchmark="${benchmark}"]`);
            
            cpuBar.style.width = `${(cpuTime / maxTime) * 100}%`;
            gpuBar.style.width = `${(gpuTime / maxTime) * 100}%`;
            
            cpuBar.textContent = formatTime(cpuTime);
            gpuBar.textContent = formatTime(gpuTime);
        }
        
        function clearResults() {
            const benchmarks = ['matrix', 'ntt', 'homomorphic', 'polynomial'];
            benchmarks.forEach(benchmark => {
                document.getElementById(`${benchmark}-cpu`).textContent = '-';
                document.getElementById(`${benchmark}-gpu`).textContent = '-';
                document.getElementById(`${benchmark}-speedup`).textContent = 'Run benchmark to see results';
                document.getElementById(`${benchmark}-speedup`).style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                
                const cpuBar = document.querySelector(`.chart-fill.cpu[data-benchmark="${benchmark}"]`);
                const gpuBar = document.querySelector(`.chart-fill.gpu[data-benchmark="${benchmark}"]`);
                
                cpuBar.style.width = '0%';
                gpuBar.style.width = '0%';
                cpuBar.textContent = '';
                gpuBar.textContent = '';
            });
            
            logMessage('Results cleared', 'info');
        }
        
        // CPU Implementations
        function cpuMatrixMultiply(size) {
            const a = new Array(size);
            const b = new Array(size);
            const result = new Array(size);
            
            // Initialize matrices
            for (let i = 0; i < size; i++) {
                a[i] = new Array(size);
                b[i] = new Array(size);
                result[i] = new Array(size);
                
                for (let j = 0; j < size; j++) {
                    a[i][j] = Math.random();
                    b[i][j] = Math.random();
                    result[i][j] = 0;
                }
            }
            
            const startTime = performance.now();
            
            // Perform matrix multiplication
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    for (let k = 0; k < size; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        function cpuNTT(size) {
            // Prime modulus for NTT (a Mersenne prime: 2^31 - 1)
            const MOD = 2147483647;
            
            // Generate random array
            const arr = new Array(size);
            for (let i = 0; i < size; i++) {
                arr[i] = Math.floor(Math.random() * MOD);
            }
            
            const startTime = performance.now();
            
            // Bit-reversed copy
            function bitReverseCopy(a) {
                const n = a.length;
                const result = new Array(n);
                
                // Calculate number of bits needed
                let bits = 0;
                while ((1 << bits) < n) bits++;
                
                // Perform bit reversal
                for (let i = 0; i < n; i++) {
                    let reversed = 0;
                    for (let j = 0; j < bits; j++) {
                        if (i & (1 << j)) {
                            reversed |= (1 << (bits - 1 - j));
                        }
                    }
                    result[reversed] = a[i];
                }
                
                return result;
            }
            
            // Calculate w^k mod MOD where w is the nth primitive root of unity
            function modPow(base, exponent, modulus) {
                if (modulus === 1) return 0;
                
                let result = 1;
                base = base % modulus;
                
                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = (result * base) % modulus;
                    }
                    exponent = Math.floor(exponent / 2);
                    base = (base * base) % modulus;
                }
                
                return result;
            }
            
            // Find primitive root of unity
            function findPrimitiveRoot(n, mod) {
                // For simplicity, we're using 3 which is a primitive root for MOD=2^31-1
                // In a real implementation, we would find an appropriate root
                return 3;
            }
            
            // Simple NTT implementation (Cooley-Tukey algorithm)
            function ntt(a, mod) {
                const n = a.length;
                
                // Check if n is a power of 2
                if ((n & (n - 1)) !== 0) {
                    throw new Error("Size must be a power of 2");
                }
                
                // Bit-reverse copy
                let result = bitReverseCopy(a);
                
                // Find primitive nth root of unity
                const primitive = findPrimitiveRoot(n, mod);
                
                // NTT computation
                for (let len = 2; len <= n; len *= 2) {
                    const halfLen = len / 2;
                    const wn = modPow(primitive, (mod - 1) / len, mod);
                    
                    for (let i = 0; i < n; i += len) {
                        let w = 1;
                        for (let j = 0; j < halfLen; j++) {
                            const u = result[i + j];
                            const v = (result[i + j + halfLen] * w) % mod;
                            
                            result[i + j] = (u + v) % mod;
                            result[i + j + halfLen] = (u - v + mod) % mod;
                            
                            w = (w * wn) % mod;
                        }
                    }
                }
                
                return result;
            }
            
            // Perform the NTT
            const result = ntt(arr, MOD);
            
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        function cpuHomomorphicVectorAdd(size) {
            // Simulate homomorphic encryption parameters
            const modulus = 1n << 30n; // A large modulus
            
            // Generate random encrypted vectors (simulated)
            const vecA = new Array(size);
            const vecB = new Array(size);
            const result = new Array(size);
            
            for (let i = 0; i < size; i++) {
                // In real homomorphic encryption, these would be ciphertexts
                // We're simulating with random BigInts
                vecA[i] = BigInt(Math.floor(Math.random() * Number(modulus)));
                vecB[i] = BigInt(Math.floor(Math.random() * Number(modulus)));
            }
            
            const startTime = performance.now();
            
            // Perform homomorphic addition (element-wise modular addition)
            for (let i = 0; i < size; i++) {
                result[i] = (vecA[i] + vecB[i]) % modulus;
            }
            
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        function cpuPolynomialMultiply(degree) {
            // Create random polynomials with coefficients in range [0, 2^16)
            const polyA = new Array(degree);
            const polyB = new Array(degree);
            const result = new Array(2 * degree - 1).fill(0);
            
            for (let i = 0; i < degree; i++) {
                polyA[i] = Math.floor(Math.random() * 65536);
                polyB[i] = Math.floor(Math.random() * 65536);
            }
            
            const startTime = performance.now();
            
            // Perform polynomial multiplication (convolution)
            for (let i = 0; i < degree; i++) {
                for (let j = 0; j < degree; j++) {
                    result[i + j] += polyA[i] * polyB[j];
                }
            }
            
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        // WebGPU Implementation
        async function initWebGPU() {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("Couldn't request WebGPU adapter.");
            }
            
            const device = await adapter.requestDevice();
            return { adapter, device };
        }
        
        async function gpuMatrixMultiply(device, size) {
            // Matrix multiplication shader
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> a: array<f32>;
                @group(0) @binding(1) var<storage, read> b: array<f32>;
                @group(0) @binding(2) var<storage, read_write> result: array<f32>;
                
                struct Uniforms {
                    size: u32,
                };
                
                @group(0) @binding(3) var<uniform> uniforms: Uniforms;
                
                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let row = global_id.x;
                    let col = global_id.y;
                    let size = uniforms.size;
                    
                    if (row >= size || col >= size) {
                        return;
                    }
                    
                    var sum: f32 = 0.0;
                    for (var i: u32 = 0; i < size; i++) {
                        sum += a[row * size + i] * b[i * size + col];
                    }
                    
                    result[row * size + col] = sum;
                }
            `;
            
            // Create shader module
            const shaderModule = device.createShaderModule({
                code: shaderCode
            });
            
            // Initialize matrices with random data
            const a = new Float32Array(size * size);
            const b = new Float32Array(size * size);
            const result = new Float32Array(size * size);
            
            for (let i = 0; i < size * size; i++) {
                a[i] = Math.random();
                b[i] = Math.random();
            }
            
            // Create GPU buffers
            const aBuffer = device.createBuffer({
                size: a.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const bBuffer = device.createBuffer({
                size: b.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const resultBuffer = device.createBuffer({
                size: result.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            
            const uniformBuffer = device.createBuffer({
                size: 4, // Single u32 for size
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            
            // Write data to buffers
            device.queue.writeBuffer(aBuffer, 0, a);
            device.queue.writeBuffer(bBuffer, 0, b);
            device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size]));
            
            // Create bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'storage' }
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'uniform' }
                    }
                ]
            });
            
            const pipelineLayout = device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            });
            
            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    entryPoint: 'main'
                }
            });
            
            // Create bind group
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: aBuffer }
                    },
                    {
                        binding: 1,
                        resource: { buffer: bBuffer }
                    },
                    {
                        binding: 2,
                        resource: { buffer: resultBuffer }
                    },
                    {
                        binding: 3,
                        resource: { buffer: uniformBuffer }
                    }
                ]
            });
            
            // Create command encoder
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);
            
            // Dispatch workgroups
            const workgroupSize = 8;
            const workgroupCount = Math.ceil(size / workgroupSize);
            computePass.dispatchWorkgroups(workgroupCount, workgroupCount);
            computePass.end();
            
            // Create a buffer to read back the result
            const readbackBuffer = device.createBuffer({
                size: result.byteLength,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            
            // Copy result to readback buffer
            commandEncoder.copyBufferToBuffer(resultBuffer, 0, readbackBuffer, 0, result.byteLength);
            
            // Submit GPU commands
            const startTime = performance.now();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
            
            // Wait for GPU to finish
            await readbackBuffer.mapAsync(GPUMapMode.READ);
            
            // Calculate elapsed time
            const endTime = performance.now();
            const elapsedTime = endTime - startTime;
            
            // Clean up
            readbackBuffer.unmap();
            
            return elapsedTime;
        }
        
        async function gpuNTT(device, size) {
            // NTT shader using Cooley-Tukey algorithm
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> input: array<u32>;
                @group(0) @binding(1) var<storage, read_write> output: array<u32>;
                
                struct Uniforms {
                    size: u32,
                    stage: u32,
                    halfStageSize: u32,
                    omega: u32,
                    modulus: u32
                };
                
                @group(0) @binding(2) var<uniform> uniforms: Uniforms;
                
                // Modular multiplication avoiding overflow
                fn mulMod(a: u32, b: u32, mod: u32) -> u32 {
                    return u32(((u64(a) * u64(b)) % u64(mod)));
                }
                
                // Modular addition
                fn addMod(a: u32, b: u32, mod: u32) -> u32 {
                    let sum = a + b;
                    return select(sum, sum - mod, sum >= mod);
                }
                
                // Modular subtraction
                fn subMod(a: u32, b: u32, mod: u32) -> u32 {
                    return select(a - b, a - b + mod, a < b);
                }
                
                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let idx = global_id.x;
                    let stage = uniforms.stage;
                    let halfStageSize = uniforms.halfStageSize;
                    let modulus = uniforms.modulus;
                    
                    // Check if this thread should process data
                    if (idx >= uniforms.size / 2) {
                        return;
                    }
                    
                    // Calculate indices for butterfly operation
                    let stageSize = halfStageSize * 2;
                    let stageIndex = idx / halfStageSize;
                    let butterflyIndex = idx % halfStageSize;
                    
                    let i1 = stageIndex * stageSize + butterflyIndex;
                    let i2 = i1 + halfStageSize;
                    
                    // Skip if indices are out of bounds
                    if (i2 >= uniforms.size) {
                        return;
                    }
                    
                    // Read values
                    let x1 = input[i1];
                    let x2 = input[i2];
                    
                    // Calculate twiddle factor
                    let w = 1u;
                    if (butterflyIndex > 0) {
                        w = mulMod(uniforms.omega, butterflyIndex, modulus);
                    }
                    
                    // Butterfly operation
                    let y1 = addMod(x1, mulMod(x2, w, modulus), modulus);
                    let y2 = subMod(x1, mulMod(x2, w, modulus), modulus);
                    
                    // Write results
                    output[i1] = y1;
                    output[i2] = y2;
                }
            `;
            
            // Create shader module
            const shaderModule = device.createShaderModule({
                code: shaderCode
            });
            
            // Initialize input data with random values
            const MOD = 2147483647; // 2^31 - 1 (Mersenne prime)
            const input = new Uint32Array(size);
            for (let i = 0; i < size; i++) {
                input[i] = Math.floor(Math.random() * MOD);
            }
            
            // Create GPU buffers
            const inputBuffer = device.createBuffer({
                size: input.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
            });
            
            const outputBuffer = device.createBuffer({
                size: input.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
            });
            
            const uniformBuffer = device.createBuffer({
                size: 5 * 4, // 5 u32 values
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            
            // Write input data to GPU
            device.queue.writeBuffer(inputBuffer, 0, input);
            
            // Create bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'storage' }
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'uniform' }
                    }
                ]
            });
            
            const pipelineLayout = device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            });
            
            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    entryPoint: 'main'
                }
            });
            
            // Calculate the number of stages (log2 of size)
            const numStages = Math.log2(size);
            
            // Prepare for timing
            const startTime = performance.now();
            
            // Create bind groups and execute stages
            let sourceBuffer = inputBuffer;
            let destBuffer = outputBuffer;
            
            for (let stage = 0; stage < numStages; stage++) {
                const stageSize = 2 ** (stage + 1);
                const halfStageSize = stageSize / 2;
                
                // A primitive root for our modulus
                const omega = 3; // For simplicity using a value that works for our modulus
                
                // Update uniform buffer for this stage
                device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([
                    size,           // size
                    stage,          // stage
                    halfStageSize,  // halfStageSize
                    omega,          // omega (primitive root)
                    MOD             // modulus
                ]));
                
                // Create bind group for this stage
                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: sourceBuffer }
                        },
                        {
                            binding: 1,
                            resource: { buffer: destBuffer }
                        },
                        {
                            binding: 2,
                            resource: { buffer: uniformBuffer }
                        }
                    ]
                });
                
                // Execute this stage
                const commandEncoder = device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();
                
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, bindGroup);
                
                // Dispatch workgroups (each workgroup handles 256 threads)
                const workgroupSize = 256;
                const workgroupCount = Math.ceil(size / (2 * workgroupSize));
                computePass.dispatchWorkgroups(workgroupCount);
                
                computePass.end();
                
                // Submit commands for this stage
                device.queue.submit([commandEncoder.finish()]);
                
                // Swap buffers for next stage
                [sourceBuffer, destBuffer] = [destBuffer, sourceBuffer];
            }
            
            // Wait for all commands to complete
            await device.queue.onSubmittedWorkDone();
            
            // Calculate elapsed time
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        async function gpuHomomorphicVectorAdd(device, size) {
            // Shader for homomorphic (modular) vector addition
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> vecA: array<u32>;
                @group(0) @binding(1) var<storage, read> vecB: array<u32>;
                @group(0) @binding(2) var<storage, read_write> result: array<u32>;
                
                struct Uniforms {
                    size: u32,
                    modulus: u32,
                };
                
                @group(0) @binding(3) var<uniform> uniforms: Uniforms;
                
                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let index = global_id.x;
                    let size = uniforms.size;
                    let modulus = uniforms.modulus;
                    
                    if (index >= size) {
                        return;
                    }
                    
                    // Modular addition
                    let sum = vecA[index] + vecB[index];
                    result[index] = select(sum, sum - modulus, sum >= modulus);
                }
            `;
            
            // Create shader module
            const shaderModule = device.createShaderModule({
                code: shaderCode
            });
            
            // Initialize vectors with random data
            const MODULUS = 1073741824; // 2^30, simulating a portion of a larger modulus
            const vecA = new Uint32Array(size);
            const vecB = new Uint32Array(size);
            
            for (let i = 0; i < size; i++) {
                vecA[i] = Math.floor(Math.random() * MODULUS);
                vecB[i] = Math.floor(Math.random() * MODULUS);
            }
            
            // Create GPU buffers
            const vecABuffer = device.createBuffer({
                size: vecA.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const vecBBuffer = device.createBuffer({
                size: vecB.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const resultBuffer = device.createBuffer({
                size: vecA.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            
            const uniformBuffer = device.createBuffer({
                size: 8, // Two u32 values
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            
            // Write data to buffers
            device.queue.writeBuffer(vecABuffer, 0, vecA);
            device.queue.writeBuffer(vecBBuffer, 0, vecB);
            device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size, MODULUS]));
            
            // Create bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'storage' }
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'uniform' }
                    }
                ]
            });
            
            const pipelineLayout = device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            });
            
            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    entryPoint: 'main'
                }
            });
            
            // Create bind group
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: vecABuffer }
                    },
                    {
                        binding: 1,
                        resource: { buffer: vecBBuffer }
                    },
                    {
                        binding: 2,
                        resource: { buffer: resultBuffer }
                    },
                    {
                        binding: 3,
                        resource: { buffer: uniformBuffer }
                    }
                ]
            });
            
            // Create command encoder
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);
            
            // Dispatch workgroups
            const workgroupSize = 256;
            const workgroupCount = Math.ceil(size / workgroupSize);
            computePass.dispatchWorkgroups(workgroupCount);
            computePass.end();
            
            // Submit GPU commands
            const startTime = performance.now();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
            
            // Wait for GPU to finish
            await device.queue.onSubmittedWorkDone();
            
            // Calculate elapsed time
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        async function gpuPolynomialMultiply(device, degree) {
            // Polynomial multiplication shader (using convolution)
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> polyA: array<u32>;
                @group(0) @binding(1) var<storage, read> polyB: array<u32>;
                @group(0) @binding(2) var<storage, read_write> result: array<u32>;
                
                struct Uniforms {
                    degree: u32,
                };
                
                @group(0) @binding(3) var<uniform> uniforms: Uniforms;
                
                @compute @workgroup_size(256)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let resultIdx = global_id.x;
                    let degree = uniforms.degree;
                    let resultSize = 2 * degree - 1;
                    
                    if (resultIdx >= resultSize) {
                        return;
                    }
                    
                    var sum: u32 = 0;
                    
                    // Compute polynomial convolution
                    for (var i: u32 = 0; i <= resultIdx; i++) {
                        if (i < degree && (resultIdx - i) < degree) {
                            sum += polyA[i] * polyB[resultIdx - i];
                        }
                    }
                    
                    result[resultIdx] = sum;
                }
            `;
            
            // Create shader module
            const shaderModule = device.createShaderModule({
                code: shaderCode
            });
            
            // Initialize polynomials with random coefficients
            const polyA = new Uint32Array(degree);
            const polyB = new Uint32Array(degree);
            const resultSize = 2 * degree - 1;
            
            for (let i = 0; i < degree; i++) {
                polyA[i] = Math.floor(Math.random() * 65536);
                polyB[i] = Math.floor(Math.random() * 65536);
            }
            
            // Create GPU buffers
            const polyABuffer = device.createBuffer({
                size: polyA.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const polyBBuffer = device.createBuffer({
                size: polyB.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            const resultBuffer = device.createBuffer({
                size: resultSize * 4, // Uint32Array elements are 4 bytes each
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            
            const uniformBuffer = device.createBuffer({
                size: 4, // Single u32 for degree
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            
            // Write data to buffers
            device.queue.writeBuffer(polyABuffer, 0, polyA);
            device.queue.writeBuffer(polyBBuffer, 0, polyB);
            device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([degree]));
            
            // Create bind group layout and pipeline layout
            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'read-only-storage' }
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'storage' }
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.COMPUTE,
                        buffer: { type: 'uniform' }
                    }
                ]
            });
            
            const pipelineLayout = device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout]
            });
            
            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: pipelineLayout,
                compute: {
                    module: shaderModule,
                    entryPoint: 'main'
                }
            });
            
            // Create bind group
            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: polyABuffer }
                    },
                    {
                        binding: 1,
                        resource: { buffer: polyBBuffer }
                    },
                    {
                        binding: 2,
                        resource: { buffer: resultBuffer }
                    },
                    {
                        binding: 3,
                        resource: { buffer: uniformBuffer }
                    }
                ]
            });
            
            // Create command encoder
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);
            
            // Dispatch workgroups
            const workgroupSize = 256;
            const workgroupCount = Math.ceil(resultSize / workgroupSize);
            computePass.dispatchWorkgroups(workgroupCount);
            computePass.end();
            
            // Submit GPU commands
            const startTime = performance.now();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
            
            // Wait for GPU to finish
            await device.queue.onSubmittedWorkDone();
            
            // Calculate elapsed time
            const endTime = performance.now();
            return endTime - startTime;
        }
        
        // Benchmark Functions
        async function runBenchmark(benchmark) {
            const sizes = getWorkloadSizes();
            const iterations = getIterationCount();
            let cpuTimes = [];
            let gpuTimes = [];
            
            updateBenchmarkUI(benchmark, 'running');
            logMessage(`Starting ${benchmark} benchmark with ${iterations} iterations...`, 'info');
            
            try {
                // Initialize WebGPU
                const { device } = await initWebGPU();
                
                for (let i = 0; i < iterations; i++) {
                    logMessage(`Running iteration ${i + 1}/${iterations}...`, 'info');
                    
                    // Run CPU benchmark
                    let cpuTime;
                    switch (benchmark) {
                        case 'matrix':
                            cpuTime = cpuMatrixMultiply(sizes.matrixSize);
                            break;
                        case 'ntt':
                            cpuTime = cpuNTT(sizes.nttSize);
                            break;
                        case 'homomorphic':
                            cpuTime = cpuHomomorphicVectorAdd(sizes.homomorphicSize);
                            break;
                        case 'polynomial':
                            cpuTime = cpuPolynomialMultiply(sizes.polynomialDegree);
                            break;
                    }
                    cpuTimes.push(cpuTime);
                    logMessage(`CPU time (iteration ${i + 1}): ${formatTime(cpuTime)}`, 'info');
                    
                    // Run GPU benchmark
                    let gpuTime;
                    switch (benchmark) {
                        case 'matrix':
                            gpuTime = await gpuMatrixMultiply(device, sizes.matrixSize);
                            break;
                        case 'ntt':
                            gpuTime = await gpuNTT(device, sizes.nttSize);
                            break;
                        case 'homomorphic':
                            gpuTime = await gpuHomomorphicVectorAdd(device, sizes.homomorphicSize);
                            break;
                        case 'polynomial':
                            gpuTime = await gpuPolynomialMultiply(device, sizes.polynomialDegree);
                            break;
                    }
                    gpuTimes.push(gpuTime);
                    logMessage(`GPU time (iteration ${i + 1}): ${formatTime(gpuTime)}`, 'info');
                    
                    // Small delay between iterations
                    if (i < iterations - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                // Calculate average times
                const avgCpuTime = cpuTimes.reduce((a, b) => a + b, 0) / cpuTimes.length;
                const avgGpuTime = gpuTimes.reduce((a, b) => a + b, 0) / gpuTimes.length;
                
                // Update UI with results
                updateBenchmarkResults(benchmark, avgCpuTime, avgGpuTime);
                
                const speedup = avgCpuTime / avgGpuTime;
                if (speedup >= 1) {
                    logMessage(`Benchmark ${benchmark} complete! WebGPU is ${speedup.toFixed(1)}x faster`, 'success');
                } else {
                    logMessage(`Benchmark ${benchmark} complete! CPU is ${(1/speedup).toFixed(1)}x faster`, 'info');
                }
                
                updateBenchmarkUI(benchmark, 'complete');
            } catch (error) {
                logMessage(`Error in ${benchmark} benchmark: ${error.message}`, 'error');
                updateBenchmarkUI(benchmark, 'error');
            }
        }
        
        async function runAllBenchmarks() {
            const benchmarks = ['matrix', 'ntt', 'homomorphic', 'polynomial'];
            const runAllBtn = document.getElementById('run-all-btn');
            
            runAllBtn.disabled = true;
            runAllBtn.innerHTML = '<div class="loading-spinner"></div> Running All...';
            
            logMessage('Starting all benchmarks...', 'info');
            
            for (const benchmark of benchmarks) {
                await runBenchmark(benchmark);
                // Small delay between benchmarks
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            runAllBtn.disabled = false;
            runAllBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg> Run All Benchmarks';
            
            logMessage('All benchmarks completed!', 'success');
        }
        
        // Initialize UI and check WebGPU support
        async function initialize() {
            const webgpuStatus = document.getElementById('webgpu-status');
            const webgpuMessage = document.getElementById('webgpu-message');
            const adapterInfo = document.getElementById('adapter-info');
            const deviceLimits = document.getElementById('device-limits');
            
            try {
                // Check if WebGPU is supported
                if (!navigator.gpu) {
                    throw new Error("WebGPU is not supported in this browser");
                }
                
                // Request adapter
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error("Failed to get WebGPU adapter");
                }
                
                // Get adapter info
                let adapterInfoText = "";
                try {
                    const info = await adapter.requestAdapterInfo();
                    adapterInfoText = `Adapter: ${info.description || info.vendor || "Unknown GPU"}`;
                    if (info.device) adapterInfoText += ` (${info.device})`;
                } catch (error) {
                    adapterInfoText = "Adapter info not available";
                }
                
                adapterInfo.textContent = adapterInfoText;
                
                // Request device
                const device = await adapter.requestDevice();
                
                // Check device limits
                const limits = [
                    `Max Workgroup Size: ${device.limits.maxComputeWorkgroupSizeX}×${device.limits.maxComputeWorkgroupSizeY}×${device.limits.maxComputeWorkgroupSizeZ}`,
                    `Max Storage Buffer Binding Size: ${(device.limits.maxStorageBufferBindingSize / (1024 * 1024)).toFixed(1)} MB`,
                    `Max Buffer Size: ${(device.limits.maxBufferSize / (1024 * 1024)).toFixed(1)} MB`
                ];
                
                deviceLimits.innerHTML = limits.map(limit => `<div>${limit}</div>`).join('');
                
                // Update status
                webgpuStatus.className = 'status-indicator supported';
                webgpuMessage.textContent = 'WebGPU is supported and working!';
                webgpuMessage.className = 'status-message supported';
                
                logMessage('WebGPU initialized successfully.', 'success');
                
                // Attach event listeners to benchmark buttons
                document.querySelectorAll('.benchmark-btn').forEach(button => {
                    const benchmark = button.getAttribute('data-benchmark');
                    button.addEventListener('click', () => runBenchmark(benchmark));
                });
                
                // Attach event listener to "Run All" button
                document.getElementById('run-all-btn').addEventListener('click', runAllBenchmarks);
                
                // Attach event listener to "Clear Results" button
                document.getElementById('clear-results-btn').addEventListener('click', clearResults);
                
            } catch (error) {
                webgpuStatus.className = 'status-indicator unsupported';
                webgpuMessage.textContent = `WebGPU is not supported: ${error.message}`;
                webgpuMessage.className = 'status-message unsupported';
                
                // Disable benchmark buttons
                document.querySelectorAll('.benchmark-btn').forEach(button => {
                    button.disabled = true;
                    button.title = 'WebGPU not available';
                });
                
                document.getElementById('run-all-btn').disabled = true;
                document.getElementById('adapter-info').textContent = 'No WebGPU adapter found';
                
                logMessage(`WebGPU initialization failed: ${error.message}`, 'error');
            }
        }
        
        // Initialize when the page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
